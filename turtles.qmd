---
title: "Turtles"
format: html
---

Let's setup the environment (bridgesampling currently works only with rstan):

```{r setup, message=FALSE,warning=FALSE, results="hide"}
library(SBC)
library(ggplot2)
library(bridgesampling)
library(dplyr)
library(tidyr)
library(calibrationband)

use_cmdstanr <- FALSE
library(rstan)
rstan_options(auto_write = TRUE)

library(future)


cache_dir <- here::here("cache")
if(!dir.exists(cache_dir)) {
  dir.create(cache_dir)
}

do_tests <- FALSE

theme_set(theme_minimal())
devtools::load_all()
```

```{r cluster}
setup_cluster()
```



There's a weird $(1 + \sigma)^{-2}$ prior on sigma, sampling with an inverse CDF scheme:

```{r}

r_inv_one_plus_sq <- function(n) {
  p <- runif(n)
  return(p / (1 - p))
}

samps <- r_inv_one_plus_sq(1e6)
xlim <- 100

samps <- samps[samps < xlim]

x_vals <- seq(1e-2, max(xlim), length.out = 200)

pdf_df <- data.frame(x = x_vals, y = (1 + x_vals)^-2)



p <- ggplot(data.frame(x = samps), aes(x)) + geom_density(bounds = c(0, xlim)) + 
  geom_line(data = pdf_df, aes(y = y), color = "blue") + coord_cartesian(xlim = c(0, xlim))
p
p + scale_y_log10()

```

```{r}
x_vals <- seq(0,10, length.out = 100)
pdf_df <- data.frame(x = x_vals, y = (1 + x_vals)^-2)
chisq_df <- data.frame(x = x_vals, y = dchisq(x_vals,df = 1))
ggplot() + aes(x = x ,y = y) + geom_line(data = pdf_df, aes(y = y), color = "blue") + geom_line(data = chisq_df, aes(y = y), color = "red") 

ggplot() + aes(x = x ,y = y) + geom_line(data = pdf_df, aes(y = y), color = "blue") + geom_line(data = chisq_df, aes(y = y), color = "red")  + scale_y_log10()
```


```{r, comment = ""}
cat(readLines("stan/turtles_H0.stan"), sep = "\n")
```

```{r compile-models}
m_H0 <- stan_model("stan/turtles_H0.stan")
m_H1 <- stan_model("stan/turtles_H1.stan")
m_H1_chisq <- stan_model("stan/turtles_H1_chisq.stan")
```

## Following `bridgesampling` example

```{r}
data("turtles", package = "bridgesampling")
force(turtles)

sim_turtles <- function(model, N = NULL, C = NULL, sigma2_prior = "default") {
  if(is.null(N)) {
    stopifnot(is.null(C))
    fixed_predictors <- TRUE
    
    N <- nrow(turtles)
    C <- max(turtles$clutch)
    clutch <- turtles$clutch
    x <- turtles$x
  } else {
    stopifnot(!is.null(C))
    stopifnot(N >= 3 * C)
    fixed_predictors <- FALSE
  }

  ## Rejection sampling to avoid low-variability datasets
  for(i in 1:200) {

    alpha0_raw <- rnorm(1) 
    alpha1_raw <- rnorm(1) 
    alpha0 <- sqrt(10) * alpha0_raw
    alpha1 <- sqrt(10) * alpha1_raw
    
    if(!fixed_predictors) {
      clutch <- rep(1:C, length.out = N)

      x <- rnorm(N) / 3  
    }
    
    
    log_lik_shared <- dnorm(alpha0_raw, log = TRUE) +
      dnorm(alpha1_raw, log = TRUE)
    
    if(model == 0) {
      predictor <- alpha0 + alpha1 * x
      log_lik_spec <- 0
    } else {
      if(sigma2_prior == "default") {
        sigma2_clutch <- r_inv_one_plus_sq(1)
      } else if(sigma2_prior == "chisq") {
        sigma2_clutch <- rchisq(1, df = 1)
      } else {
        stop("Invalid sigma2_prior")
      }
      sigma_clutch <- sqrt(sigma2_clutch)      
      
      b_clutch_raw <- rnorm(C)
      b_clutch <- b_clutch_raw * sigma_clutch
      
      predictor <- alpha0 + alpha1 * x + b_clutch[clutch]
      
      log_lik_spec <- 
        log(sigma2_clutch)  +# Jacobian
        (- 2 * log1p(sigma2_clutch)) + 
        #log(sigma_clutch) + dnorm(sigma_clutch, log = TRUE) + log(2) +
        sum(dnorm(b_clutch_raw, log = TRUE))
    }
    
    #prob <- plogis(predictor)
    prob <- pnorm(predictor)
    y <- rbinom(N, p = prob, size = 1)
    if(mean(y == 0) < 0.9 && mean(y == 1) < 0.9) {
      break
    }
  }
  if(i >= 200) {
    warning("Could not generate nice dataset")
  }
  
  log_lik_predictor <- sum(dbinom(y, size = 1, p = prob, log = TRUE))
  
  variables <- list(
      alpha0 = alpha0,
      alpha1 = alpha1,
      lp__ = log_lik_shared + log_lik_spec + log_lik_predictor
    )
  
  if(model == 1) {
    variables$sigma <- sigma_clutch
    variables$b <- b_clutch
  } 

  list(
    generated = list(
      N = N,
      y = y,
      x = x,
      C = C,
      clutch = clutch
    ),
    variables = variables
  )
}
```



```{r test1}
if(do_tests) {
set.seed(4524865)
  N <- NULL
  C <- NULL
  ds_test_1 <- generate_datasets(SBC_generator_function(sim_turtles, N = N, C = C, model = 1), n_sims = 400)
  backend_H1 <- SBC_backend_rstan_sample(m_H1, init = 0, control = list(adapt_delta = 0.9))
  res_test1 <- compute_SBC(ds_test_1, backend_H1, 
                           keep_fits = FALSE,
                           cache_mode = "results",
                           cache_location = file.path(cache_dir, paste0("SBC_turtles_H1_N", N, "_C",C,"_", length(ds_test_1), ".rds")))
  
  plot_ecdf_diff(res_test1, combine_variables = combine_array_elements)
}
```

```{r simulateds}
N <- NULL
C <- NULL

set.seed(54223248)
N_sims <- 1000
gen_globals <- c("r_inv_one_plus_sq", "turtles")
ds_turtles_m0 <- generate_datasets(SBC_generator_function(sim_turtles, model = 0, N = N, C = C, future.globals = gen_globals), n_sims = N_sims)
ds_turtles_m1 <- generate_datasets(SBC_generator_function(sim_turtles, model = 1, N = N, C = C, future.globals = gen_globals), n_sims = N_sims)

set.seed(3148955)
ds_turtles <- SBC_datasets_for_bf(ds_turtles_m0, ds_turtles_m1)
```

```{r turtles1}
iter <- 15500
warmup <- 500
init <- 0
backend_turtles <- SBC_backend_bridgesampling(
  SBC_backend_rstan_sample(m_H0, iter = iter, warmup = warmup, init = init),
  SBC_backend_rstan_sample(m_H1, iter = iter, warmup = warmup, init = init)
)
res_turtles <- compute_SBC(ds_turtles, backend_turtles, 
                           keep_fits = FALSE,
                           cache_mode = "results",
                           cache_location = file.path(cache_dir, "turtles_1.rds"))
```

```{r}
res_turtles$errors[!purrr::map_lgl(res_turtles$errors, is.null)]
```


```{r}
res_turtles$stats
```


```{r}
plot_ecdf_diff(res_turtles, combine_variables = combine_array_elements)
plot_rank_hist(res_turtles, variables = "model", bins = 20)

```

```{r}
bp_turtles <- binary_probabilities_from_stats(res_turtles$stats)
t.test(bp_turtles$prob, mu = 0.5)
miscalibration_resampling_p(bp_turtles$prob, bp_turtles$simulated_value)
my_reliability_diag(bp_turtles)
```
Just those without error in BF

```{r}
no_error_index <- res_turtles$backend_diagnostics$bs_error_H0 == 0 & res_turtles$backend_diagnostics$bs_error_H1 == 0
plot_ecdf_diff(res_turtles[no_error_index], combine_variables = combine_array_elements)
t.test(bp_turtles$prob[no_error_index], mu = 0.5)
my_reliability_diag(bp_turtles[no_error_index,])
```



```{r ecdf-split}
stats_split <- split_SBC_results_for_bf(res_turtles)
plot_ecdf_diff(stats_split$stats_H0)
plot_ecdf_diff(stats_split$stats_H1, combine_variables = combine_array_elements)
```

## Chi-squared prior

```{r simulateds-chisq}
set.seed(84662)
ds_turtles_m1_chisq <- generate_datasets(SBC_generator_function(sim_turtles, model = 1, N = NULL, C = NULL, sigma2_prior = "chisq", future.globals = "turtles"), n_sims = length(ds_turtles_m0))
ds_turtles_chisq <- SBC_datasets_for_bf(ds_turtles_m0, ds_turtles_m1_chisq)
```


```{r turtles1}
backend_turtles_chisq <- SBC_backend_bridgesampling(
  SBC_backend_rstan_sample(m_H0, iter = iter, warmup = warmup, init = init),
  SBC_backend_rstan_sample(m_H1_chisq, iter = iter, warmup = warmup, init = init)
)
res_turtles_chisq <- compute_SBC(ds_turtles_chisq, backend_turtles_chisq, 
                           keep_fits = FALSE,
                           cache_mode = "results",
                           cache_location = file.path(cache_dir, "turtles_1_chisq.rds"))
```



```{r}
plot_ecdf_diff(res_turtles_chisq, combine_variables = combine_array_elements)
plot_rank_hist(res_turtles_chisq, variables = "model", bins = 20)

```

```{r}
bp_turtles_chisq <- binary_probabilities_from_stats(res_turtles_chisq$stats)
t.test(bp_turtles_chisq$prob, mu = 0.5)
miscalibration_resampling_p(bp_turtles_chisq$prob, bp_turtles_chisq$simulated_value)
my_reliability_diag(bp_turtles_chisq)
```

## Warp3



```{r warp3}
backend_turtles_w <- SBC_backend_bridgesampling(
  SBC_backend_rstan_sample(m_H0, iter = iter, warmup = warmup, init = init),
  SBC_backend_rstan_sample(m_H1, iter = iter, warmup = warmup, init = init),
  method = "warp3", repetitions = 5
)
res_turtles_w <- compute_SBC(ds_turtles, backend_turtles_w, 
                           keep_fits = FALSE,
                           cache_mode = "results",
                           cache_location = file.path(cache_dir, "turtles_1_w.rds"))
```


```{r}
plot_ecdf_diff(res_turtles_w, combine_variables = combine_array_elements)
plot_binary_calibration_diff(res_turtles_w$stats)
plot_rank_hist(res_turtles_w, variables = "model", bins = 20)

```

```{r}
res_turtles_w$backend_diagnostics$prob_H1 %>% hist()
res_turtles_w$backend_diagnostics$prob_H1 %>% mean()
```


## More warmup

```{r more-warmup}
backend_turtles_more <- SBC_backend_bridgesampling(
  SBC_backend_rstan_sample(m_H0, iter = iter + 1000, warmup = warmup + 1000, init = init),
  SBC_backend_rstan_sample(m_H1, iter = iter + 1000, warmup = warmup + 1000, init = init)
)
res_turtles_more <- compute_SBC(ds_turtles, backend_turtles_more, 
                           keep_fits = FALSE,
                           cache_mode = "results",
                           cache_location = file.path(cache_dir, "turtles_1_more.rds"))
```


```{r}
plot_ecdf_diff(res_turtles_more, combine_variables = combine_array_elements)
plot_binary_calibration_diff(res_turtles_more$stats)
plot_rank_hist(res_turtles_more, variables = "model", bins = 20)

```

## More data

```{r turtles2}
set.seed(784522)
N_sims <- 2000
N <- 80
C <- 10
ds_turtles_m0_2 <- generate_datasets(SBC_generator_function(sim_turtles, model = 0, N = N, C = C, future.globals = gen_globals), n_sims = N_sims)
ds_turtles_m1_2 <- generate_datasets(SBC_generator_function(sim_turtles, model = 1, N = N, C = C, future.globals = gen_globals), n_sims = N_sims)
ds_turtles_2 <- SBC_datasets_for_bf(ds_turtles_m0_2, ds_turtles_m1_2)

res_turtles_2 <- compute_SBC(ds_turtles_2, backend_turtles, 
                           keep_fits = FALSE,
                           cache_mode = "results",
                           cache_location = file.path(cache_dir, "turtles_2.rds"))

```

```{r}
res_turtles_2$backend_diagnostics$prob_H1 %>% hist() 
plot_ecdf_diff(res_turtles_2)
plot_binary_calibration_diff(res_turtles_2$stats)
plot_ecdf_diff(res_turtles_2$stats)
```


```{r}
bp_turtles_2 <- binary_probabilities_from_stats(res_turtles_2$stats)
t.test(bp_turtles_2$prob, mu = 0.5)
miscalibration_resampling_p(bp_turtles_2$prob, bp_turtles_2$simulated_value)
```


```{r}
if(!("log_prob_H1" %in% names(res_turtles$backend_diagnostics))) {
  res_turtles$backend_diagnostics$log_prob_H1 <- log(res_turtles$backend_diagnostics$prob_H1)
}
```




```{r}
res_turtles_all <- bind_results(res_turtles, res_turtles_2)
plot_ecdf_diff(res_turtles_all, variables = c("model", "lp__"))
res_turtles_all$stats %>% group_by(variable) %>% tally()
plot_binary_calibration_diff(res_turtles_all$stats)
```





```{r}
iter <- 15500
warmup <- 500
init <- 0
backend_turtles_warp <- SBC_backend_bridgesampling(
  SBC_backend_rstan_sample(m_H0, iter = iter, warmup = warmup, init = init),
  SBC_backend_rstan_sample(m_H1, iter = iter, warmup = warmup, init = init),
  method = "warp3",
  repetitions = 5
)
# TODO avoid the need for repetitions by not requiring error_meausres
res_turtles_w <- compute_SBC(ds_turtles, backend_turtles_warp, 
                           keep_fits = FALSE,
                           cache_mode = "results",
                           cache_location = file.path(cache_dir, "turtles_1_w.rds"))
```



