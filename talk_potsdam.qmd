---
title: "SBC for Bayes Factors"
subtitle: "Potsdam, 2025-02-20"
html-math-method: mathjax
format: 
  revealjs
    
---

```{r setup}
devtools::load_all()
library(dplyr)
library(patchwork)
library(ggplot2)

theme_set(theme_minimal())
```


# BMA model

$$
\begin{aligned}
i &\sim \text{Categorical}(\text{Pr}(\mathcal{M}_0), \dots, \text{Pr}(\mathcal{M}_{K - 1}) )\\
\theta_i &\sim \pi^i_\text{prior} \\
y &\sim \pi_\text{obs}^i(\theta_i)
\end{aligned}
$$

::: {.fragment}
$$
\text{Pr}(\mathcal{M}_i | y) = \pi_\text{BMA}(i | y) = \frac{\pi^i_\text{marg}(y)\text{Pr}(\mathcal{M}_i)}{\sum_{j=0}^{K - 1} \pi^j_\text{marg}(y)\text{Pr}(\mathcal{M}_j)}
$$

:::


# Posterior calibration - Binary

Among the cases where $\text{Pr}(\mathcal{M}_i | y) = x\%$ the
true model should be $i$ in $x\%$ of the cases.

# Posterior calibration - Continous

"In 95% of simulations, the true variable lies within the central 95% posterior credible interval."


  - Variable = parameter or a function of parameter(s) and data


::: {.fragment}
"In x% of simulations, the true variable lies within the x% posterior credible interval (of any kind)"
:::

# SBC

For each simulation take the rank of the true value within the samples
  - Rank: no. of samples < true value

Across simulations, this rank should be uniformly distributed between $0$ and $S$

::: {.fragment}
This is _exactly_ continuous posterior calibration!
:::

::: {.fragment}
With random tie-breaking, this is _exactly_ binary posterior calibration

Power(SBC) $\neq$ Power(Calibration)
:::

# SBC and DAP

"Data-averaged posterior = prior"

Doesn't care about ordering!

Calibration cares about ordering

SBC $\neq$ DAP

# Counterexamples for DAP

 - Flip probabilities
 - $\mathcal{M}_0 = \mathcal{M}_1$
 - Compute something different

# Counterexamples for both

 - Ignoring data
 - Derived quantities FTW!

# SBC and DAP theory

- DAP w.r.t. $f \;\not\!\!\!\implies$ SBC w.r.t. $f$
- SBC w.r.t. $f \;\not\!\!\!\implies$ DAP w.r.t. $f$

::: {.fragment}
- SBC w.r.t. all data-independent $f \implies$ DAP w.r.t. all data-independent $f$
- DAP w.r.t. all data-independent $f \;\not\!\!\!\implies$ SBC w.r.t. all data-independent $f$
::: 

::: {.fragment}
- SBC w.r.t. all $f \implies$ model is correct
- DAP w.r.t. all $f \implies$ model is correct (likely)
:::

::: {.fragment}
   - But this requires "simulating SBC with DAP", so not practical
:::


# Example - binary

$$
\begin{aligned}
Y = \{0,1\} \\
\text{Pr}(y = 1 | \mathcal{M}_0) &= \frac{1}{3}, \: \text{Pr}(y = 1 | \mathcal{M}_1) = \frac{2}{3} \\
\text{Pr}(\mathcal{M}_0) = \text{Pr}(\mathcal{M}_1) &= \frac{1}{2}
\end{aligned}
$$

# Example - binary - flipped probabilities

```{r}
#| fig-width: 7
#| fig-height: 2.5
hist_binary_flip <- load_histories("binary_flip", "binary_example.qmd")
(plot_log_gamma_histories(hist_binary_flip$log_gamma) | 
plot_log_p_histories(hist_binary_flip$miscalibration, "Miscalibration") | 
plot_log_p_histories(hist_binary_flip$schad, "DAP - t-test")) + plot_annotation(tag_levels = "A") + plot_layout(widths = c(2,1,1), axis_titles = "collect_x")
```

# Example - Poisson vs. NB 

$$
\begin{aligned}
\mathcal{M}_0: y_1,\dots,y_N &\sim \text{Poisson}(3)\\
\mathcal{M}_1: y_1,\dots,y_N &\sim \text{NB}_2(3, 5)\\
\text{Pr}(\mathcal{M}_0) &= \text{Pr}(\mathcal{M}_1) = \frac{1}{2}
\end{aligned}
$$


# Poisson vs. NB

ignoring all data

```{r}
#| fig-width: 7
#| fig-height: 5

hist_pnb_ignore_all <- load_histories("pnb_ignore_all", "poisson_nb_example.qmd")
plot_log_gamma_histories(hist_pnb_ignore_all$log_gamma) / (
plot_log_p_histories(hist_pnb_ignore_all$miscalibration, "Miscalibration") +
  plot_spacer()
) +
#plot_log_p_histories(hist_pnb_ignore_all$schad, "DAP - t-test")) + 
  plot_annotation(tag_levels = "A")
```

# Poisson vs. NB

ignoring half data

```{r}
#| fig-width: 7
#| fig-height: 5

hist_pnb_ignore_half <- load_histories("pnb_ignore_half", "poisson_nb_example.qmd")
plot_log_gamma_histories(hist_pnb_ignore_half$log_gamma) / (
plot_log_p_histories(hist_pnb_ignore_half$miscalibration, "Miscalibration") + 
plot_log_p_histories(hist_pnb_ignore_half$schad, "DAP - t-test")) + plot_annotation(tag_levels = "A")
```

# Poisson vs. NB

unbiased noise in BF

```{r}
#| fig-width: 7
#| fig-height: 5

hist_pnb_vari <- load_histories("pnb_vari", "poisson_nb_example.qmd")
plot_log_gamma_histories(hist_pnb_vari$log_gamma) / (
plot_log_p_histories(hist_pnb_vari$miscalibration, "Miscalibration") + 
plot_log_p_histories(hist_pnb_vari$schad, "DAP - t-test")) + plot_annotation(tag_levels = "A")
```

# Poisson vs. NB

bias in BF

```{r}
#| fig-width: 7
#| fig-height: 5

hist_pnb_bias <- load_histories("pnb_bias", "poisson_nb_example.qmd")
plot_log_gamma_histories(hist_pnb_bias$log_gamma) / (
plot_log_p_histories(hist_pnb_bias$miscalibration, "Miscalibration") + 
plot_log_p_histories(hist_pnb_bias$schad, "DAP - t-test")) + plot_annotation(tag_levels = "A")
```

# Poisson vs. NB

bias + noise in BF

```{r}
#| fig-width: 7
#| fig-height: 5

hist_pnb_bias_vari <- load_histories("pnb_bias_vari", "poisson_nb_example.qmd")
plot_log_gamma_histories(hist_pnb_bias_vari$log_gamma) / (
plot_log_p_histories(hist_pnb_bias_vari$miscalibration, "Miscalibration") + 
plot_log_p_histories(hist_pnb_bias_vari$schad, "DAP - t-test")) + plot_annotation(tag_levels = "A")
```

# SBC and DAP summary

- Counterexamples for SBC/calibration hard to construct
- Counterexamples for DAP easy to construct and plausible
- In some (but not most) cases DAP more sensitive


# Posterior SBC
 - Akiâ€™s paper!
 - Targeting
 - Component-wise priors unrealistic
 - Improper priors
 - Related to prequenial definition of Bayes factors / sequential updating
 - Need to compute BF and use that as a new prior (or tweak prior)
 
# Post-SBC tweak prior

We want:

<!--
$$
P(\mathcal{M}_1 | y_1) = \frac{\pi_\text{marg}(y_1 | \mathcal{M}_1)  P(\mathcal{M}_1) }{ \pi_\text{marg}(y_1 | \mathcal{M}_1)  P(\mathcal{M}_1) + \pi_\text{marg}(y_1 | \mathcal{M}_0)  (1 - P(\mathcal{M}_1))} = t
$$
-->
$$
\begin{aligned}
\frac{1}{2} &= P(\mathcal{M}_1 | y_1) = \\
&= \frac{\pi_\text{marg}(y_1 | \mathcal{M}_1)  P(\mathcal{M}_1) }{ \pi_\text{marg}(y_1 | \mathcal{M}_1)  P(\mathcal{M}_1) + \pi_\text{marg}(y_1 | \mathcal{M}_0)  (1 - P(\mathcal{M}_1))}
\end{aligned}
$$

::: {.fragment}
Solve for $P(\mathcal{M}_1)$:

<!-- $$ -->
<!-- P(\mathcal{M}_1) =  \frac{ t \pi_\text{marg}(y_1 | \mathcal{M}_0)}{(1 - t)\pi_\text{marg}(y_1 | \mathcal{M}_1) + t\pi_\text{marg}(y_1 | \mathcal{M}_0)} -->
<!-- $$ -->

$$
P(\mathcal{M}_1) =  \frac{ \pi_\text{marg}(y_1 | \mathcal{M}_0)}{\pi_\text{marg}(y_1 | \mathcal{M}_1) + \pi_\text{marg}(y_1 | \mathcal{M}_0)}
$$

:::


# Example - ranef/lmbf

$$
\begin{aligned}
y_i &\sim  N(\alpha + \beta x_{i} + \gamma_{g_i}, \sigma),  &i = 1,2,\ldots,N\\
\gamma_j &\sim N\left(0, \frac{\sqrt{2}}{4}\sigma \sqrt{\tau} \right), &j = 1,2,\ldots, G \\
\tau &\sim \text{InvGamma}\left(\frac{1}{2},\frac{1}{2} \right), &
\beta \sim N\left(0, \frac{\sqrt{2}}{4} \sigma \right), \\  
\pi_\text{prior}(\alpha_0, \sigma^2) &= \frac{1}{\sigma^2}  & 
\mathcal{M}_0 : \tau = 0
\end{aligned}
$$

# With constant prior


```{r}
#| fig-width: 7
#| fig-height: 5

hist_ranef_constant <- load_histories("ranef_constant", "lmbf_ranef_presence_post_sbc.qmd")
plot_log_gamma_histories(hist_ranef_constant$log_gamma) / (
plot_log_p_histories(hist_ranef_constant$miscalibration, "Miscalibration") + 
plot_log_p_histories(hist_ranef_constant$schad, "DAP - t-test")) + plot_annotation(tag_levels = "A")
```


# Rejection sampling
 - Another way to overcome bad prior
 - Needs to be done on the whole model, not the submodels!


# Testing DAP
 - Bayes t-test vs. normal t-test vs. non-parametric test

```{r}
p_power <- readRDS("cache/figs_power.rds")
p_power$bad
```

# Testing DAP 

```{r}
p_power$correct
```

# Testing DAP

```{r}
p_power$ci_width
```

