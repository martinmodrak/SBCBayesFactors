---
title: "lmBF 2x2 from Schad & Vasishth"
format: html
---

This requires the most recent `bayes_factors` branch in the SBC package repo: `remotes::install_github("hyunjimoon/SBC@bayes_factors")`

```{r setup}
library(SBC)
library(ggplot2)
library(dplyr)
library(rstan)

library(BayesFactor)



options(mc.cores = 12 , SBC.min_chunk_size = 50)
rstan_options(auto_write = TRUE)

cache_dir <- here::here("cache")
if(!dir.exists(cache_dir)) {
  dir.create(cache_dir)
}

cache_fits_dir <- file.path(cache_dir, "fits_lmbf")
if(!dir.exists(cache_fits_dir)) {
  dir.create(cache_fits_dir)
}

devtools::load_all()
theme_set(theme_minimal())
```

```{r cluster}
future::plan(future::multisession, workers = parallel::detectCores)
```


First, we wrap the simulation code in a function for better usage. We also keep track
of the simulated values for some variables, but other than that there are no changes.

```{r}
prior_model_H1 <- stan_model("stan/lmbf_linreg_bin_1rand.stan")
prior_model_H0 <- stan_model("stan/lmbf_linreg_bin.stan")
```

```{r}
f_H0 <- y ~ 1 + x1 
f_H1 <- update(f_H0, . ~ . + Subject)


r_scale_fixed <- sqrt(2) / 4
r_scale_random <- sqrt(2) / 4
r_scale_cont <- sqrt(2) / 4
scenario_mod <- ""
# r_scale_fixed <- sqrt(2) / 4
# r_scale_random <- 1
# r_scale_cont <- sqrt(2) / 4
# scenario_mod <- "_scale2"

set.seed(5482334)
N_prior_data <- 12
N_prior_subjects <- 4


sim_lmbf_ranef_data <- function(N, N_subjects) {
  stopifnot(N_subjects <= N)
  stopifnot(N >= 4)
  data.frame(id = 1:N,
             x1 = c("A","A","B","B", sample(c("A", "B"), size = N - 4, replace = TRUE)),
             Subject = factor(c(1:N_subjects, sample.int(N_subjects, size = N - N_subjects, replace = TRUE))))
}



subject_ranef <- rnorm(N_prior_subjects)
prior_df <- sim_lmbf_ranef_data(N_prior_data, N_prior_subjects) %>%
  mutate(y = rnorm(N_prior_data) + 0.5 * (x1 == "B") + if_else(id < N_prior_data * 0.6, subject_ranef[as.integer(Subject)], 0))


mm_H0 <- model.matrix(f_H0, prior_df)[, -1, drop = FALSE]

prior_data_stan <- list(N = N_prior_data, r_fixed = r_scale_fixed, r_random = r_scale_random, y = prior_df$y,
                        K = ncol(mm_H0),
                        X = mm_H0,
                             G = N_prior_subjects, group = as.integer(prior_df$Subject))

# prior_data_stan_H0 <- prior_data_stan_base
# mm_H0 <- model.matrix(f_H0, prior_df)[, -1, drop = FALSE]
# prior_data_stan_H0$X <- mm_H0
# prior_data_stan_H0$K <- ncol(mm_H0)
# 
# prior_data_stan_H1 <- prior_data_stan_base
# mm_H1 <- model.matrix(f_H1, prior_df)[, -1, drop = FALSE]
# prior_data_stan_H1$X <- mm_H1
# prior_data_stan_H1$K <- ncol(mm_H1)


res_prior_H0 <- sampling(prior_model_H0, data = prior_data_stan, iter = 16000, warmup = 1000, thin = 10)
res_prior_H1 <- sampling(prior_model_H1, data = prior_data_stan, iter = 16000, warmup = 1000, thin = 10, control = list(adapt_delta = 0.99))

draws_prior_H1 <- posterior::as_draws_matrix(res_prior_H1)
draws_prior_H0 <- posterior::as_draws_matrix(res_prior_H0)


bf_H1 <- lmBF(f_H1, data = prior_df, whichRandom = "Subject", rscaleFixed = r_scale_fixed, rscaleCont = r_scale_cont, rscaleRandom = r_scale_random)
if(all(as.character(f_H0) == as.character(y ~ 1))) {
  bf_prior <- extractBF(bf_H1)
} else {
  bf_H0 <- lmBF(f_H0, data = prior_df, rscaleFixed = r_scale_fixed, rscaleCont = r_scale_cont, rscaleRandom = r_scale_random)
  bf_prior <- extractBF(bf_H1 / bf_H0, logbf = TRUE)
}
prob1_prior <- exp(bf_prior$bf) / (1 + exp(bf_prior$bf))


bs_prior_H0 <- bridgesampling::bridge_sampler(res_prior_H0)
bs_prior_H1 <- bridgesampling::bridge_sampler(res_prior_H1)
bf_prior_bs <- bridgesampling::bayes_factor(bs_prior_H1, bs_prior_H0)

bridgesampling::error_measures(bs_prior_H0)
bridgesampling::error_measures(bs_prior_H1)

cat(exp(bf_prior$bf), " err: ", bf_prior$error, "\n")
bf_prior_bs
```

```{r}
draws_lmbf_H1 <- lmBF(f_H1, data = prior_df, whichRandom = "Subject", rscaleFixed = r_scale_fixed, rscaleCont = r_scale_cont, rscaleRandom = r_scale_random, posterior = TRUE, iterations = 2000)
draws_lmbf_H0 <- lmBF(f_H0, data = prior_df, whichRandom = "Subject", rscaleFixed = r_scale_fixed, rscaleCont = r_scale_cont, rscaleRandom = r_scale_random, posterior = TRUE, iterations = 2000)
```



```{r}
sim_lmbf_ranef_posterior <- function(N, N_subjects, formula, df_prior, draws, rscaleFixed = r_scale_fixed, rscaleRandom = r_scale_random) {
  draws <- posterior::merge_chains(draws)
  draw_id <- sample.int(posterior::ndraws(draws), size = 1)

  
  alpha <- as.numeric(draws[draw_id, "alpha"])
  sigma <- as.numeric(draws[draw_id, "sigma"])
  
  df <- sim_lmbf_ranef_data(N, N_subjects)
  df$y <- 0 #dummy
  X <- model.matrix(formula, df)[, -1, drop = FALSE]
  K <- ncol(X)
  # Transform 0/1 to the contrasts used by lmBF
  X_prime <- -(X - 0.5) * sqrt(2)

  rvars_chosen_draw <- posterior::as_draws_rvars(posterior::subset_draws(draws, draw = draw_id))
  beta <- as.numeric(posterior::draws_of(rvars_chosen_draw$beta)) 

  
  ranef <- as.numeric(posterior::draws_of(rvars_chosen_draw$ranef))
  if(length(ranef) < N_subjects) {
    ranef_g <- as.numeric(draws[draw_id, "g_ranef"])
    ranef_new <- rnorm(N_subjects - length(ranef)) * sqrt(ranef_g) * sigma * rscaleRandom;
    ranef <- c(ranef, ranef_new)
  }
      
  mu <- alpha + X_prime %*% beta + ranef[df$Subject]
  df$y <- rnorm(N, mean = mu, sd = sigma)
  
  variables <- list(
      mu = alpha,
      sig2 = sigma^2,
      `x1-A` = beta[1] / sqrt(2),
      g_Subject = ranef_g * rscaleRandom^2
    )
  for(i in 1:N_subjects) {
    variables[[paste0("Subject-", i)]] <- ranef[i]
  }
  if(length(beta) == 2) {
    variables[["x2-I"]] <- beta[2] / sqrt(2)
  }
  
  return(list(
    generated = rbind(df_prior, df),
    variables = variables))
}

sim_lmbf_fixed_posterior <- function(N, N_subjects, formula, df_prior, draws, rscaleFixed = r_scale_fixed) {
  draws <- posterior::merge_chains(draws)
  draw_id <- sample.int(posterior::ndraws(draws), size = 1)

  
  alpha <- as.numeric(draws[draw_id, "alpha"])
  sigma <- as.numeric(draws[draw_id, "sigma"])
  
  df <- sim_lmbf_ranef_data(N, N_subjects)
  df$y <- 0 #dummy
  X <- model.matrix(formula, df)[, -1, drop = FALSE]
  K <- ncol(X)
  # Transform 0/1 to the contrasts used by lmBF
  X_prime <- -(X - 0.5) * sqrt(2)

  beta_rvar <- posterior::as_draws_rvars(posterior::subset_draws(draws, draw = draw_id))$beta
  
  beta <- as.numeric(posterior::draws_of(beta_rvar)) 
    
  mu <- alpha + X_prime %*% beta
  df$y <- rnorm(N, mean = mu, sd = sigma)
  
  variables <- list(
      mu = alpha,
      sig2 = sigma^2,
      `x1-A` = beta[1] / sqrt(2)
    )
  if(length(beta) == 2) {
    variables[["x2-I"]] <- beta[2] / sqrt(2)
  }
  
  return(list(
    generated = rbind(df_prior, df),
    variables = variables))
}

```


# Post SBC

```{r}
set.seed(854230)
N <- 100 - nrow(prior_df)
N_subjects <- 15
n_sims <- 10000

ds_lmbf_post_H0 <- generate_datasets(SBC_generator_function(sim_lmbf_fixed_posterior, formula = f_H0, N = N, N_subjects = N_subjects, df_prior = prior_df, draws = draws_prior_H0), n_sims = n_sims)
ds_lmbf_post_H1 <- generate_datasets(SBC_generator_function(sim_lmbf_ranef_posterior, formula = f_H0, N = N, N_subjects = N_subjects, df_prior = prior_df, draws = draws_prior_H1), n_sims = n_sims)
```



```{r}
set.seed(21485654)
ds_post <- SBC_datasets_for_bf(ds_lmbf_post_H0, ds_lmbf_post_H1, prob_H1 = prob1_prior)

backend_H0 <- SBC_backend_lmBF(f_H0, rscaleFixed = r_scale_fixed, rscaleCont = r_scale_cont, rscaleRandom = r_scale_random)
backend_H1 <- SBC_backend_lmBF(f_H1, whichRandom = "Subject", rscaleFixed = r_scale_fixed, rscaleCont = r_scale_cont, rscaleRandom = r_scale_random)

backend_post <- SBC_backend_extractBF_comparison(backend_H0, backend_H1)
N_for_filename <- nrow(ds_post$generated[[1]])
res_post <- compute_SBC(ds_post, backend_post, keep_fits = FALSE,
                            cache_mode = "results",
                            cache_location = file.path(cache_dir, paste0("lmbf_ranef_post_presence_", N_for_filename, scenario_mod, ".rds")))

plot_ecdf_diff(res_post, combine_variables = combine_lmBF_arrays)
bp_post <- binary_probabilities_from_stats(res_post$stats)
t.test(bp_post$prob, mu = prob1_prior)
ml_dap_p(bp_post$prob, mu = prob1_prior )
miscalibration_resampling_p(bp_post$prob, bp_post$simulated_value)
reliabilitydiag::reliabilitydiag(x = bp_post$prob, y = bp_post$simulated_value)

```




```{r}
res_split <- split_SBC_results_for_bf(res_post)
plot_ecdf_diff(res_split$stats_H0, combine_variables = combine_lmBF_arrays)
plot_ecdf_diff(res_split$stats_H1, combine_variables = combine_lmBF_arrays)

#TODO explore the missing `simulated_value` cases.
plot_sim_estimated(res_split$stats_H0)
plot_sim_estimated(res_split$stats_H1)
```



# Constant prior

```{r}
sim_lmbf_ranef <- function(N, N_subjects, formula, alpha_sigma_prior, rscaleFixed = r_scale_fixed, rscaleRandom = r_scale_random) {
  if(is.function(alpha_sigma_prior)) {
    alpha_sigma <- alpha_sigma_prior()
  } else {
    alpha_sigma <- alpha_sigma_prior
  }
  alpha <- alpha_sigma$alpha
  sigma <- alpha_sigma$sigma
  
  df <- sim_lmbf_ranef_data(N, N_subjects)
  df$y <- 0 #dummy
  X <- model.matrix(formula, df)[, -1, drop = FALSE]
  K <- ncol(X)
  # Transform 0/1 to the contrasts used by lmBF
  X_prime <- -(X - 0.5) * sqrt(2)

  beta_std <- rcauchy(K, scale = rscaleFixed)
  beta <- beta_std * sigma
  
  ranef_g <- rscaleRandom^2 / rgamma(1, 0.5, scale = 0.5)

  ranef <- rnorm(N_subjects) * sqrt(ranef_g) * sigma

  mu <- alpha + X_prime %*% beta + ranef[df$Subject]
  df$y <- rnorm(N, mean = mu, sd = sigma)
  
  variables <- list(
      mu = alpha,
      sig2 = sigma^2,
      `x1-A` = beta[1] / sqrt(2),
      g_Subject = ranef_g #* r_scale_random
    )
  for(i in 1:N_subjects) {
    variables[[paste0("Subject-", i)]] <- ranef[i]
  }
  if(length(beta) == 2) {
    variables[["x2-I"]] <- beta[2] / sqrt(2)
  }
  
  return(list(
    generated = df,
    variables = variables))
}

sim_lmbf_fixed <- function(N, N_subjects, formula, alpha_sigma_prior, rscaleFixed = r_scale_fixed) {
  if(is.function(alpha_sigma_prior)) {
    alpha_sigma <- alpha_sigma_prior()
  } else {
    alpha_sigma <- alpha_sigma_prior
  }
  alpha <- alpha_sigma$alpha
  sigma <- alpha_sigma$sigma
  
  df <- sim_lmbf_ranef_data(N, N_subjects)
  df$y <- 0 #dummy
  X <- model.matrix(formula, df)[, -1, drop = FALSE]
  K <- ncol(X)
  # Transform 0/1 to the contrasts used by lmBF
  X_prime <- -(X - 0.5) * sqrt(2)
  
  beta_std <- rcauchy(K, scale = rscaleFixed)
  beta <- beta_std * sigma
  mu <- alpha + X_prime %*% beta
  df$y <- rnorm(N, mean = mu, sd = sigma)
  
  variables <- list(
      mu = alpha,
      sig2 = sigma^2,
      `x1-A` = beta[1] / sqrt(2)
    )
  if(length(beta) == 2) {
    variables[["x2-I"]] <- beta[2] / sqrt(2)
  }
  
  return(list(
    generated = df,
    variables = variables))
}

```

```{r}
set.seed(3485524)
N <- 100
N_subjects <- 15
n_sims <- 100
constant_alpha_sigma <- list(alpha = 200, sigma = 50)
ds_lmbf_constant_H0 <- generate_datasets(SBC_generator_function(sim_lmbf_fixed, N = N, N_subjects = N_subjects, formula = f_H0, alpha_sigma_prior = constant_alpha_sigma), n_sims = n_sims)
ds_lmbf_constant_H1 <- generate_datasets(SBC_generator_function(sim_lmbf_ranef, N = N, N_subjects = N_subjects, formula = f_H0, alpha_sigma_prior = constant_alpha_sigma), n_sims = n_sims)

```


```{r}
set.seed(42264855)
ds_constant <- SBC_datasets_for_bf(ds_lmbf_constant_H0, ds_lmbf_constant_H1)
backend_constant <- SBC_backend_extractBF_comparison(backend_H0, backend_H1)
N_for_filename <- nrow(ds_constant$generated[[1]])
res_constant <- compute_SBC(ds_constant, backend_constant, keep_fits = FALSE,
                            cache_mode = "results",
                            cache_location = file.path(cache_dir, paste0("lmbf_ranef_post_presence_constant_", N_for_filename, scenario_mod, ".rds")))

plot_ecdf_diff(res_constant, combine_variables = combine_lmBF_arrays)
bp_constant <- binary_probabilities_from_stats(res_constant$stats)
t.test(bp_constant$prob, mu = 0.5)
ml_dap_p(bp_constant$prob)
miscalibration_resampling_p(bp_constant$prob, bp_constant$simulated_value)
reliabilitydiag::reliabilitydiag(x = bp_constant$prob, y = bp_constant$simulated_value)
```


```{r}
res_split_constant <- split_SBC_results_for_bf(res_constant)
plot_ecdf_diff(res_split_constant$stats_H0, combine_variables = combine_lmBF_arrays)
plot_ecdf_diff(res_split_constant$stats_H1, combine_variables = combine_lmBF_arrays)

#TODO explore the missing `simulated_value` cases.
plot_sim_estimated(res_split_constant$stats_H0)
plot_sim_estimated(res_split_constant$stats_H0 %>% filter(variable == "g_Subject") %>% mutate(across(all_of(c("simulated_value", "mean", "q5", "q95")), log10 )))
plot_sim_estimated(res_split_constant$stats_H1)
plot_sim_estimated(res_split_constant$stats_H1 %>% filter(variable == "g_Subject") %>% mutate(across(all_of(c("simulated_value", "mean", "q5", "q95")), log10 )))

```


## Constant prior nicer

```{r}
set.seed(854624)
N <- 100
N_subjects <- 15
n_sims <- 1000
constant2_alpha_sigma <- list(alpha = 0, sigma = 1)
ds_lmbf_constant2_H0 <- generate_datasets(SBC_generator_function(sim_lmbf_fixed, N = N, N_subjects = N_subjects, formula = f_H0, alpha_sigma_prior = constant2_alpha_sigma), n_sims = n_sims)
ds_lmbf_constant2_H1 <- generate_datasets(SBC_generator_function(sim_lmbf_ranef, N = N, N_subjects = N_subjects, formula = f_H0, alpha_sigma_prior = constant2_alpha_sigma), n_sims = n_sims)

```


```{r}
set.seed(42264855)
ds_constant2 <- SBC_datasets_for_bf(ds_lmbf_constant2_H0, ds_lmbf_constant2_H1)
backend_constant2 <- backend_constant
N_for_filename <- nrow(ds_constant2$generated[[1]])
res_constant2 <- compute_SBC(ds_constant2, backend_constant2, keep_fits = FALSE,
                            cache_mode = "results",
                            cache_location = file.path(cache_dir, paste0("lmbf_ranef_post_presence_constant2_", N_for_filename, ".rds")))

plot_ecdf_diff(res_constant2, combine_variables = combine_lmBF_arrays)
bp_constant2 <- binary_probabilities_from_stats(res_constant2$stats)
t.test(bp_constant2$prob, mu = 0.5)
ml_dap_p(bp_constant2$prob)
miscalibration_resampling_p(bp_constant2$prob, bp_constant2$simulated_value)
reliabilitydiag::reliabilitydiag(x = bp_constant2$prob, y = bp_constant2$simulated_value)
```
