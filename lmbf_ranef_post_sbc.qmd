---
title: "lmBF 2x2 from Schad & Vasishth"
format: html
---

This requires the most recent `bayes_factors` branch in the SBC package repo: `remotes::install_github("hyunjimoon/SBC@bayes_factors")`

```{r setup}
library(SBC)
library(ggplot2)
library(dplyr)
library(rstan)

library(BayesFactor)



options(mc.cores = 12 , SBC.min_chunk_size = 50)
rstan_options(auto_write = TRUE)

cache_dir <- here::here("cache")
if(!dir.exists(cache_dir)) {
  dir.create(cache_dir)
}

cache_fits_dir <- file.path(cache_dir, "fits_lmbf")
if(!dir.exists(cache_fits_dir)) {
  dir.create(cache_fits_dir)
}

devtools::load_all()
theme_set(theme_minimal())
```

```{r cluster}
setup_cluster()
```


First, we wrap the simulation code in a function for better usage. We also keep track
of the simulated values for some variables, but other than that there are no changes.

```{r}
prior_model <- stan_model("stan/lmbf_linreg_bin_1rand.stan")
```

```{r}
f_H1 <- y ~ 1 + x1 + x2
f_H0 <- y ~ 1 + x1

f_H1_ranef <- update(f_H1, . ~. + Subject)
f_H0_ranef <- update(f_H0, . ~. + Subject)

r_scale <- sqrt(2) / 4

#set.seed(322155)
# N_prior_data <- 400
# prior_df <- data.frame(id = 1:N_prior_data, x1 = sample(c("A", "B"), size = N_prior_data, replace = TRUE)) %>%
#   mutate(y = rnorm(N_prior_data))

set.seed(5482334)
N_prior_data <- 20
N_prior_subjects <- 4

# set.seed(5482334)
# N_prior_data <- 300
# N_prior_subjects <- 20

sim_lmbf_ranef_data <- function(N, N_subjects) {
  stopifnot(N_subjects <= N)
  stopifnot(N >= 4)
  data.frame(id = 1:N,
             # Ensure that all combinations exist
             x1 = c("A","A","B","B", sample(c("A", "B"), size = N - 4, replace = TRUE)),
             x2 = c("I","J","I","J", sample(c("I", "J"), size = N - 4, replace = TRUE)),
             Subject = factor(c(1:N_subjects, sample.int(N_subjects, size = N - N_subjects, replace = TRUE))))
}

prior_df <- sim_lmbf_ranef_data(N_prior_data, N_prior_subjects) %>%
  mutate(y = rnorm(N_prior_data) + (x1 == "B") + if_else(id < N_prior_data * 0.9, 0, (x2 == "J")))


prior_data_stan_base <- list(N = N_prior_data, r_fixed = r_scale, r_random = r_scale, y = prior_df$y,
                             G = N_prior_subjects, group = as.integer(prior_df$Subject))

prior_data_stan_H0 <- prior_data_stan_base
mm_H0 <- model.matrix(f_H0, prior_df)[, -1, drop = FALSE]
prior_data_stan_H0$X <- mm_H0
prior_data_stan_H0$K <- ncol(mm_H0)

prior_data_stan_H1 <- prior_data_stan_base
mm_H1 <- model.matrix(f_H1, prior_df)[, -1, drop = FALSE]
prior_data_stan_H1$X <- mm_H1
prior_data_stan_H1$K <- ncol(mm_H1)


res_prior_H0 <- sampling(prior_model, data = prior_data_stan_H0, cores = 1, iter = 16000, warmup = 1000, thin = 10)
res_prior_H1 <- sampling(prior_model, data = prior_data_stan_H1, cores = 1, iter = 16000, warmup = 1000, thin = 10)

draws_prior_H1 <- posterior::as_draws_matrix(res_prior_H1)
draws_prior_H0 <- posterior::as_draws_matrix(res_prior_H0)


bf_H1 <- lmBF(f_H1_ranef, data = prior_df, whichRandom = "Subject", rscaleFixed = r_scale, rscaleCont = r_scale, rscaleRandom = r_scale)
bf_H0 <- lmBF(f_H0_ranef, data = prior_df, whichRandom = "Subject", rscaleFixed = r_scale, rscaleCont = r_scale, rscaleRandom = r_scale)
bf_prior_obj <- recompute(bf_H1 / bf_H0, iterations = 100000)
bf_prior <- extractBF(bf_prior_obj, logbf = TRUE)
prob1_prior <- exp(bf_prior$bf) / (1 + exp(bf_prior$bf))


bs_prior_H0 <- bridgesampling::bridge_sampler(res_prior_H0)
bs_prior_H1 <- bridgesampling::bridge_sampler(res_prior_H1)
bf_prior_bs <- bridgesampling::bayes_factor(bs_prior_H1, bs_prior_H0)

bridgesampling::error_measures(bs_prior_H0)
bridgesampling::error_measures(bs_prior_H1)

cat(exp(bf_prior$bf), " err: ", bf_prior$error, "\n")
bf_prior_bs
```

```{r}
draws_lmbf_H1 <- lmBF(f_H1_ranef, data = prior_df, whichRandom = "Subject", rscaleFixed = r_scale, rscaleCont = r_scale, rscaleRandom = r_scale, posterior = TRUE, iterations = 2000)
draws_lmbf_H0 <- lmBF(f_H0_ranef, data = prior_df, whichRandom = "Subject", rscaleFixed = r_scale, rscaleCont = r_scale, rscaleRandom = r_scale, posterior = TRUE, iterations = 2000)

hist(log(draws_lmbf_H0[,"g_Subject"]))
hist(log(draws_prior_H0[,"g_ranef"] *r_scale^2 ))

hist(log(draws_lmbf_H1[,"g_Subject"]))
hist(log(draws_prior_H1[,"g_ranef"] *r_scale^2 ))


hist(draws_prior_H0[,"sigma"]^2)
hist(draws_lmbf_H0[,"sig2"])
hist(draws_prior_H0[,"ranef[1]"])
hist(draws_lmbf_H0[,"Subject-1"])
dimnames(draws_lmbf_H0)
#hist(1/rgamma(1e6, 0.5, 0.5 * r_scale))
```



```{r}
sim_lmbf_ranef_posterior <- function(N, N_subjects, formula, df_prior, draws, r_scale_fixed = r_scale, r_scale_random = r_scale) {
  draws <- posterior::merge_chains(draws)
  draw_id <- sample.int(posterior::ndraws(draws), size = 1)

  
  alpha <- as.numeric(draws[draw_id, "alpha"])
  sigma <- as.numeric(draws[draw_id, "sigma"])
  
  df <- sim_lmbf_ranef_data(N, N_subjects)
  df$y <- 0 #dummy
  X <- model.matrix(formula, df)[, -1, drop = FALSE]
  K <- ncol(X)
  # Transform 0/1 to the contrasts used by lmBF
  X_prime <- -(X - 0.5) * sqrt(2)

  rvars_chosen_draw <- posterior::as_draws_rvars(posterior::subset_draws(draws, draw = draw_id))
  beta <- as.numeric(posterior::draws_of(rvars_chosen_draw$beta)) 

  
  ranef <- as.numeric(posterior::draws_of(rvars_chosen_draw$ranef))
  if(length(ranef) < N_subjects) {
    ranef_g <- as.numeric(draws[draw_id, "g_ranef"])
    ranef_new <- rnorm(N_subjects - length(ranef)) * sqrt(ranef_g) * sigma * r_scale_random;
    ranef <- c(ranef, ranef_new)
  }
      
  mu <- alpha + X_prime %*% beta + ranef[df$Subject]
  df$y <- rnorm(N, mean = mu, sd = sigma)
  
  variables <- list(
      mu = alpha,
      sig2 = sigma^2,
      `x1-A` = beta[1] / sqrt(2),
      g_Subject = ranef_g * r_scale_random^2
    )
  for(i in 1:N_subjects) {
    variables[[paste0("Subject-", i)]] <- ranef[i]
  }
  if(length(beta) == 2) {
    variables[["x2-I"]] <- beta[2] / sqrt(2)
  }
  
  return(list(
    generated = rbind(df_prior, df),
    variables = variables))
}

```


# Post SBC

```{r}
set.seed(1223345)
N <- 100
N_subjects <- 15
n_sims <- 10000

ds_lmbf_post_H0 <- generate_datasets(SBC_generator_function(sim_lmbf_ranef_posterior, formula = f_H0, N = N, N_subjects = N_subjects, df_prior = prior_df, draws = draws_prior_H0), n_sims = n_sims)
ds_lmbf_post_H1 <- generate_datasets(SBC_generator_function(sim_lmbf_ranef_posterior, formula = f_H1, N = N, N_subjects = N_subjects, df_prior = prior_df, draws = draws_prior_H1), n_sims = n_sims)
```



```{r}
set.seed(487522)
ds_post <- SBC_datasets_for_bf(ds_lmbf_post_H0, ds_lmbf_post_H1, prob_H1 = prob1_prior)

backend_H0 <- SBC_backend_lmBF(f_H0_ranef, whichRandom = "Subject", rscaleFixed = r_scale, rscaleCont = r_scale, rscaleRandom = r_scale)
backend_H1 <- SBC_backend_lmBF(f_H1_ranef, whichRandom = "Subject", rscaleFixed = r_scale, rscaleCont = r_scale, rscaleRandom = r_scale)

backend_post <- SBC_backend_extractBF_comparison(backend_H0, backend_H1)
N_for_filename <- nrow(ds_post$generated[[1]])
res_post <- compute_SBC(ds_post, backend_post, keep_fits = FALSE,
                            cache_mode = "results",
                            cache_location = file.path(cache_dir, paste0("lmbf_ranef_post_", N_for_filename, ".rds")))

plot_ecdf_diff(res_post, combine_variables = combine_lmBF_arrays)
bp_post <- binary_probabilities_from_stats(res_post$stats)
t.test(bp_post$prob, mu = prob1_prior)
ml_dap_p(bp_post$prob, mu = prob1_prior )
miscalibration_resampling_p(bp_post$prob, bp_post$simulated_value)
reliabilitydiag::reliabilitydiag(x = bp_post$prob, y = bp_post$simulated_value)

```

```{r}
bp_post %>% filter(prob < 0.2) %>% arrange(desc(prob)) %>% select(simulated_value, prob) %>%
  group_by(round(prob, digits = 2)) %>% summarise(n = n(), mean(simulated_value))


bp_post_ss <- bp_post %>% filter(prob < 0.2) %>% arrange(desc(prob)) %>% select(simulated_value, prob) %>%
   summarise(n = n(), true = sum(simulated_value), mean(simulated_value))
bp_post_ss

binom.test(bp_post_ss$true, bp_post_ss$n)

```



```{r}
res_split <- split_SBC_results_for_bf(res_post)
plot_ecdf_diff(res_split$stats_H0, combine_variables = combine_lmBF_arrays)
plot_ecdf_diff(res_split$stats_H1, combine_variables = combine_lmBF_arrays)

#TODO explore the missing `simulated_value` cases.
plot_sim_estimated(res_split$stats_H0)
plot_sim_estimated(res_split$stats_H1)
```



# Constant prior

```{r}
sim_lmbf_ranef <- function(N, N_subjects, formula, alpha_sigma_prior, r_scale_fixed = r_scale, r_scale_random = r_scale) {
  if(is.function(alpha_sigma_prior)) {
    alpha_sigma <- alpha_sigma_prior()
  } else {
    alpha_sigma <- alpha_sigma_prior
  }
  alpha <- alpha_sigma$alpha
  sigma <- alpha_sigma$sigma
  
  df <- sim_lmbf_ranef_data(N, N_subjects)
  df$y <- 0 #dummy
  X <- model.matrix(formula, df)[, -1, drop = FALSE]
  K <- ncol(X)
  # Transform 0/1 to the contrasts used by lmBF
  X_prime <- -(X - 0.5) * sqrt(2)

  beta_std <- rcauchy(K, scale = r_scale_fixed)
  beta <- beta_std * sigma
  
  ranef_g <- r_scale_random^2 / rgamma(1, 0.5, scale = 0.5)
    
  ranef <- rnorm(N_subjects) * sqrt(ranef_g) * sigma

  mu <- alpha + X_prime %*% beta + ranef[df$Subject]
  df$y <- rnorm(N, mean = mu, sd = sigma)
  
  variables <- list(
      mu = alpha,
      sig2 = sigma^2,
      `x1-A` = beta[1] / sqrt(2),
      g_Subject = ranef_g #* r_scale_random
    )
  for(i in 1:N_subjects) {
    variables[[paste0("Subject-", i)]] <- ranef[i]
  }
  if(length(beta) == 2) {
    variables[["x2-I"]] <- beta[2] / sqrt(2)
  }
  
  return(list(
    generated = df,
    variables = variables))
}

```

```{r}
set.seed(2145855)
N <- 100
N_subjects <- 15
n_sims <- 10000
constant_alpha_sigma <- list(alpha = 200, sigma = 50)
ds_lmbf_constant_H0 <- generate_datasets(SBC_generator_function(sim_lmbf_ranef, N = N, N_subjects = N_subjects, formula = y ~ x1, alpha_sigma_prior = constant_alpha_sigma), n_sims = n_sims)
ds_lmbf_constant_H1 <- generate_datasets(SBC_generator_function(sim_lmbf_ranef, N = N, N_subjects = N_subjects, formula = y ~ x1 + x2, alpha_sigma_prior = constant_alpha_sigma), n_sims = n_sims)
```


```{r}
res_H0 <- compute_SBC(ds_lmbf_constant_H0[1:50], backend_H0)

plot_ecdf_diff(res_H0, combine_variables = combine_lmBF_arrays)
plot_sim_estimated(res_H0$stats)
```



```{r}
res_H1 <- compute_SBC(ds_lmbf_constant_H1[1:50], backend_H1)

plot_ecdf_diff(res_H1, combine_variables = combine_lmBF_arrays)
plot_sim_estimated(res_H1)
```

```{r}
set.seed(54122344)
ds_constant <- SBC_datasets_for_bf(ds_lmbf_constant_H0, ds_lmbf_constant_H1)
backend_constant <- SBC_backend_extractBF_comparison(backend_H0, backend_H1)
N_for_filename <- nrow(ds_constant$generated[[1]])
res_constant <- compute_SBC(ds_constant, backend_constant, keep_fits = FALSE,
                            cache_mode = "results",
                            cache_location = file.path(cache_dir, paste0("lmbf_ranef_post_constant_", N_for_filename, ".rds")))

plot_ecdf_diff(res_constant, combine_variables = combine_lmBF_arrays)
bp_constant <- binary_probabilities_from_stats(res_constant$stats)
t.test(bp_constant$prob, mu = 0.5)
ml_dap_p(bp_constant$prob)
miscalibration_resampling_p(bp_constant$prob, bp_constant$simulated_value)
reliabilitydiag::reliabilitydiag(x = bp_constant$prob, y = bp_constant$simulated_value)
```

```{r}
bp_constant %>% filter(prob < 0.2) %>% arrange(desc(prob)) %>% select(simulated_value, prob) %>%
  group_by(round(prob, digits = 2)) %>% summarise(n = n(), mean(simulated_value))

bp_constant_ss <- bp_constant %>% filter(prob < 0.2) %>% arrange(desc(prob)) %>% select(simulated_value, prob) %>%
   summarise(n = n(), true = sum(simulated_value), mean(simulated_value))
bp_constant_ss

binom.test(bp_constant_ss$true, bp_constant_ss$n)
```


```{r}
res_split_constant <- split_SBC_results_for_bf(res_constant)
plot_ecdf_diff(res_split_constant$stats_H0, combine_variables = combine_lmBF_arrays)
plot_ecdf_diff(res_split_constant$stats_H1, combine_variables = combine_lmBF_arrays)

#TODO explore the missing `simulated_value` cases.
plot_sim_estimated(res_split_constant$stats_H0)
plot_sim_estimated(res_split_constant$stats_H0 %>% filter(variable == "g_Subject") %>% mutate(across(all_of(c("simulated_value", "mean", "q5", "q95")), log10 )))
plot_sim_estimated(res_split_constant$stats_H1)
plot_sim_estimated(res_split_constant$stats_H1 %>% filter(variable == "g_Subject") %>% mutate(across(all_of(c("simulated_value", "mean", "q5", "q95")), log10 )))

```


