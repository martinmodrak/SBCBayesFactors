---
title: "lmBF 2x2 from Schad & Vasishth"
format: html
---

This requires the most recent `bayes_factors` branch in the SBC package repo: `remotes::install_github("hyunjimoon/SBC@bayes_factors")`

```{r setup}
library(SBC)
library(ggplot2)
library(dplyr)
library(rstan)

library(BayesFactor)

devtools::load_all()

options(mc.cores = 12 , SBC.min_chunk_size = 50)
rstan_options(auto_write = TRUE)

cache_dir <- here::here("cache")
if(!dir.exists(cache_dir)) {
  dir.create(cache_dir)
}

cache_fits_dir <- file.path(cache_dir, "fits_lmbf")
if(!dir.exists(cache_fits_dir)) {
  dir.create(cache_fits_dir)
}

theme_set(theme_minimal())
```

```{r cluster}
future::plan(future::multisession, workers = parallel::detectCores)
```


First, we wrap the simulation code in a function for better usage. We also keep track
of the simulated values for some variables, but other than that there are no changes.

```{r}
prior_model <- stan_model("stan/lmbf_linreg_bin.stan")
```

```{r}
f_H1 <- y ~ 1 + x1 + x2
f_H0 <- y ~ 1 + x1

#r_scale <- sqrt(2) / 4
r_scale <- 1.5

#set.seed(322155)
# N_prior_data <- 400
# prior_df <- data.frame(id = 1:N_prior_data, x1 = sample(c("A", "B"), size = N_prior_data, replace = TRUE)) %>%
#   mutate(y = rnorm(N_prior_data))

set.seed(322155)
N_prior_data <- 4

sim_lmbf_fixed_data <- function(N) {
  data.frame(id = 1:N,
             # Ensure that all combinations exist
             x1 = c("A","A","B","B", sample(c("A", "B"), size = N - 4, replace = TRUE)),
             x2 = c("I","J","I","J", sample(c("I", "J"), size = N - 4, replace = TRUE)))
}

prior_df <- sim_lmbf_fixed_data(N_prior_data) %>%
  mutate(y = rnorm(N_prior_data) + (x1 == "B") + if_else(id < N_prior_data * 0.9, 0, (x2 == "J")))


prior_data_stan_base <- list(N = N_prior_data, r_fixed = r_scale, y = prior_df$y)

prior_data_stan_H0 <- prior_data_stan_base
mm_H0 <- model.matrix(f_H0, prior_df)[, -1, drop = FALSE]
prior_data_stan_H0$X <- mm_H0
prior_data_stan_H0$K <- ncol(mm_H0)

prior_data_stan_H1 <- prior_data_stan_base
mm_H1 <- model.matrix(f_H1, prior_df)[, -1, drop = FALSE]
prior_data_stan_H1$X <- mm_H1
prior_data_stan_H1$K <- ncol(mm_H1)


res_prior_H0 <- sampling(prior_model, data = prior_data_stan_H0, cores = 1, iter = 16000, warmup = 1000, thin = 10)
res_prior_H1 <- sampling(prior_model, data = prior_data_stan_H1, cores = 1, iter = 16000, warmup = 1000, thin = 10)

draws_prior_H1 <- posterior::as_draws_matrix(res_prior_H1)
draws_prior_H0 <- posterior::as_draws_matrix(res_prior_H0)

bf_H1 <- lmBF(f_H1, data = prior_df, rscaleFixed = r_scale, rscaleCont = r_scale, rscaleRandom = r_scale)
if(all(as.character(f_H0) == as.character(y ~ 1))) {
  bf_prior <- extractBF(bf_H1)
} else {
  bf_H0 <- lmBF(f_H0, data = prior_df, rscaleFixed = r_scale, rscaleCont = r_scale, rscaleRandom = r_scale)
  bf_prior <- extractBF(bf_H1 / bf_H0, logbf = TRUE)
}
prob1_prior <- exp(bf_prior$bf) / (1 + exp(bf_prior$bf))


bs_prior_H0 <- bridgesampling::bridge_sampler(res_prior_H0)
bs_prior_H1 <- bridgesampling::bridge_sampler(res_prior_H1)
bf_prior_bs <- bridgesampling::bayes_factor(bs_prior_H1, bs_prior_H0)

bridgesampling::error_measures(bs_prior_H0)
bridgesampling::error_measures(bs_prior_H1)

cat(exp(bf_prior$bf), " err: ", bf_prior$error, "\n")
bf_prior_bs
```





# Post SBC

```{r}
sim_lmbf_fixed_posterior <- function(N, formula, df_prior, draws, r_scale_fixed = r_scale) {
  draws <- posterior::merge_chains(draws)
  draw_id <- sample.int(posterior::ndraws(draws), size = 1)

  
  alpha <- as.numeric(draws[draw_id, "alpha"])
  sigma <- as.numeric(draws[draw_id, "sigma"])
  
  df <- sim_lmbf_fixed_data(N)
  df$y <- 0 #dummy
  X <- model.matrix(formula, df)[, -1, drop = FALSE]
  K <- ncol(X)
  # Transform 0/1 to the contrasts used by lmBF
  X_prime <- -(X - 0.5) * sqrt(2)

  beta_rvar <- posterior::as_draws_rvars(posterior::subset_draws(draws, draw = draw_id))$beta
  
  beta <- as.numeric(posterior::draws_of(beta_rvar)) 
    
  mu <- alpha + X_prime %*% beta
  df$y <- rnorm(N, mean = mu, sd = sigma)
  
  variables <- list(
      mu = alpha,
      sig2 = sigma^2,
      `x1-A` = beta[1] / sqrt(2)
    )
  if(length(beta) == 2) {
    variables[["x2-I"]] <- beta[2] / sqrt(2)
  }
  
  return(list(
    generated = rbind(df_prior, df),
    variables = variables))
}

```

```{r}
set.seed(1223345)
N <- 10
n_sims <- 4000

ds_lmbf_post_H0 <- generate_datasets(SBC_generator_function(sim_lmbf_fixed_posterior, N = N, formula = y ~ x1,  draws = draws_prior_H0, df_prior = prior_df), n_sims = n_sims)
ds_lmbf_post_H1 <- generate_datasets(SBC_generator_function(sim_lmbf_fixed_posterior, N = N, formula = y ~ x1 + x2, draws = draws_prior_H1, df_prior = prior_df), n_sims = n_sims)
```

```{r}
backend_H0 <- SBC_backend_lmBF(y ~ x1, rscaleFixed = r_scale)
backend_H1 <- SBC_backend_lmBF(y ~ x1 + x2, rscaleFixed = r_scale)
```


```{r}
set.seed(6218945)
ds_post <- SBC_datasets_for_bf(ds_lmbf_post_H0, ds_lmbf_post_H1, prob_H1 = prob1_prior)
backend_post <- SBC_backend_extractBF_comparison(backend_H0, backend_H1)
N_for_filename <- nrow(ds_post$generated[[1]])
res_post <- compute_SBC(ds_post, backend_post, keep_fits = FALSE,
                            cache_mode = "results",
                            cache_location = file.path(cache_dir, paste0("lmbf_post_", N_for_filename, "_R_", round(r_scale, 2) * 100, ".rds")))

plot_ecdf_diff(res_post)
bp_post <- binary_probabilities_from_stats(res_post$stats)
t.test(bp_post$prob, mu = prob1_prior)
miscalibration_resampling_p(bp_post$prob, bp_post$simulated_value)
reliabilitydiag::reliabilitydiag(x = bp_post$prob, y = bp_post$simulated_value)

```






# Constant prior

```{r}
sim_lmbf_fixed <- function(N, formula, alpha_sigma_prior, r_scale_fixed = r_scale) {
  if(is.function(alpha_sigma_prior)) {
    alpha_sigma <- alpha_sigma_prior()
  } else {
    alpha_sigma <- alpha_sigma_prior
  }
  alpha <- alpha_sigma$alpha
  sigma <- alpha_sigma$sigma
  
  df <- sim_lmbf_fixed_data(N)
  df$y <- 0 #dummy
  X <- model.matrix(formula, df)[, -1, drop = FALSE]
  K <- ncol(X)
  # Transform 0/1 to the contrasts used by lmBF
  X_prime <- -(X - 0.5) * sqrt(2)
  
  beta_std <- rcauchy(K, scale = r_scale_fixed)
  beta <- beta_std * sigma
  mu <- alpha + X_prime %*% beta
  df$y <- rnorm(N, mean = mu, sd = sigma)
  
  variables <- list(
      mu = alpha,
      sig2 = sigma^2,
      `x1-A` = beta[1] / sqrt(2)
    )
  if(length(beta) == 2) {
    variables[["x2-I"]] <- beta[2] / sqrt(2)
  }
  
  return(list(
    generated = df,
    variables = variables))
}

```

```{r}
set.seed(2145855)
N <- 10
n_sims <- 4000
constant_alpha_sigma <- list(alpha = 200, sigma = 50)
ds_lmbf_constant_H0 <- generate_datasets(SBC_generator_function(sim_lmbf_fixed, N = N, formula = y ~ x1, alpha_sigma_prior = constant_alpha_sigma), n_sims = n_sims)
ds_lmbf_constant_H1 <- generate_datasets(SBC_generator_function(sim_lmbf_fixed, N = N, formula = y ~ x1 + x2, alpha_sigma_prior = constant_alpha_sigma), n_sims = n_sims)
```


```{r}
res_H0 <- compute_SBC(ds_lmbf_constant_H0[1:50], backend_H0)

plot_ecdf_diff(res_H0)
plot_sim_estimated(res_H0$stats)
```

```{r}
lm(mean ~ simulated_value, res_H0$stats %>% filter(variable == "x1-A", simulated_value < 1000))
1/sqrt(2)
```



```{r}
res_H1 <- compute_SBC(ds_lmbf_constant_H1[1:50], backend_H1)

plot_ecdf_diff(res_H1)
plot_sim_estimated(res_H1)
```

```{r}
set.seed(2478555)
ds_constant <- SBC_datasets_for_bf(ds_lmbf_constant_H0, ds_lmbf_constant_H1)
backend_constant <- SBC_backend_extractBF_comparison(backend_H0, backend_H1)
N_for_filename <- nrow(ds_constant$generated[[1]])
res_constant <- compute_SBC(ds_constant, backend_constant, keep_fits = FALSE,
                            cache_mode = "results",
                            cache_location = file.path(cache_dir, paste0("lmbf_post_constant_", N_for_filename, "_R_", round(r_scale, 2) * 100, ".rds")))

plot_ecdf_diff(res_constant)
bp_constant <- binary_probabilities_from_stats(res_constant$stats)
t.test(bp_constant$prob, mu = 0.5)
miscalibration_resampling_p(bp_constant$prob, bp_constant$simulated_value)

reliabilitydiag::reliabilitydiag(x = bp_constant$prob, y = bp_constant$simulated_value)

```




