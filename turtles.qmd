---
title: "Turtles"
format: html
---

Let's setup the environment (bridgesampling currently works only with rstan):

```{r setup, message=FALSE,warning=FALSE, results="hide"}
library(SBC)
library(ggplot2)
library(bridgesampling)
library(dplyr)
library(tidyr)
library(calibrationband)

use_cmdstanr <- FALSE
library(rstan)
rstan_options(auto_write = TRUE)

library(future)


cache_dir <- here::here("cache")
if(!dir.exists(cache_dir)) {
  dir.create(cache_dir)
}

do_tests <- FALSE

theme_set(theme_minimal())
devtools::load_all()
```

```{r cluster}
setup_cluster(max_server_workers = 110)
```

TODO: implement full bridgesampling workflow with brms (sampling from prior, posterior SBC via posterior_predict...)

There's a weird $(1 + \sigma)^{-2}$ prior on sigma, sampling with an inverse CDF scheme:

```{r}

r_inv_one_plus_sq <- function(n) {
  p <- runif(n)
  return(p / (1 - p))
}

samps <- r_inv_one_plus_sq(1e6)
xlim <- 100

samps <- samps[samps < xlim]

x_vals <- seq(1e-2, max(xlim), length.out = 200)

pdf_df <- data.frame(x = x_vals, y = (1 + x_vals)^-2)



p <- ggplot(data.frame(x = samps), aes(x)) + geom_density(bounds = c(0, xlim)) + 
  geom_line(data = pdf_df, aes(y = y), color = "blue") + coord_cartesian(xlim = c(0, xlim))
p
p + scale_y_log10()

```



```{r}
x_vals <- seq(0,10, length.out = 100)
pdf_df <- data.frame(x = x_vals, y = (1 + x_vals)^-2)
chisq_df <- data.frame(x = x_vals, y = dchisq(x_vals,df = 1))
ggplot() + aes(x = x ,y = y) + 
  geom_line(data = pdf_df, aes(y = y), color = "blue") + 
  geom_line(data = chisq_df, aes(y = y), color = "red") 

ggplot() + aes(x = x ,y = y) + geom_line(data = pdf_df, aes(y = y), color = "blue") + 
  geom_line(data = chisq_df, aes(y = y), color = "red") 
```


```{r compile-models}
m_H0 <- stan_model("stan/turtles_H0.stan")
m_H1 <- stan_model("stan/turtles_H1.stan")
m_H1_norm <- stan_model("stan/turtles_H1_norm.stan")
m_H1_norm_bad <- stan_model("stan/turtles_H1_norm_bad_normalization.stan")
```

## Simulator

```{r}
data("turtles", package = "bridgesampling")
force(turtles)

gen_globals <- c("r_inv_one_plus_sq", "turtles")

sim_turtles <- function(model, N = NULL, C = NULL, sigma2_prior = "default") {
  if(is.null(N)) {
    stopifnot(is.null(C))
    fixed_predictors <- TRUE
    
    N <- nrow(turtles)
    C <- max(turtles$clutch)
    clutch <- turtles$clutch
    x <- turtles$x
  } else {
    stopifnot(!is.null(C))
    stopifnot(N >= 3 * C)
    fixed_predictors <- FALSE
  }

  alpha0_raw <- rnorm(1) 
  alpha1_raw <- rnorm(1) 
  alpha0 <- sqrt(10) * alpha0_raw
  alpha1 <- sqrt(10) * alpha1_raw
  
  if(!fixed_predictors) {
    clutch <- rep(1:C, length.out = N)

    x <- rnorm(N) / 3  
  }
  
  
  log_lik_shared <- dnorm(alpha0_raw, log = TRUE) +
    dnorm(alpha1_raw, log = TRUE)
  
  if(model == 0) {
    predictor <- alpha0 + alpha1 * x
    log_lik_spec <- 0
  } else {
    if(sigma2_prior == "default") {
      sigma2_clutch <- r_inv_one_plus_sq(1)
      sigma_clutch <- sqrt(sigma2_clutch)      
      
      sigma2_log_lik <- log(sigma2_clutch)  +# Jacobian
        (- 2 * log1p(sigma2_clutch))
    } else if(sigma2_prior == "sqrt_norm") {
      sigma_clutch <- abs(rnorm(1, sd = 1))
      
      sigma2_log_lik <- log(sigma_clutch)  +# Jacobian
        log(2) + dnorm(sigma_clutch, sd = 1, log = TRUE)
    } else {
      stop("Invalid sigma2_prior")
    }

    b_clutch_raw <- rnorm(C)
    b_clutch <- b_clutch_raw * sigma_clutch
    
    predictor <- alpha0 + alpha1 * x + b_clutch[clutch]
    
    log_lik_spec <- 
      sigma2_log_lik +
      sum(dnorm(b_clutch_raw, log = TRUE))
  }
  
  prob <- pnorm(predictor)
  y <- rbinom(N, p = prob, size = 1)

  log_lik_predictor <- sum(dbinom(y, size = 1, p = prob, log = TRUE))
  
  variables <- list(
      alpha0 = alpha0,
      alpha1 = alpha1,
      lp__ = log_lik_shared + log_lik_spec + log_lik_predictor
    )
  
  if(model == 1) {
    variables$sigma <- sigma_clutch
    variables$b <- b_clutch
  } 

  list(
    generated = list(
      N = N,
      y = y,
      x = x,
      C = C,
      clutch = clutch
    ),
    variables = variables
  )
}
```


## Test individual models

```{r test1}
if(do_tests) {
set.seed(9654224)
  N <- NULL
  C <- NULL
  ds_test_1 <- generate_datasets(SBC_generator_function(sim_turtles, N = N, C = C, model = 1, future.globals = gen_globals), n_sims = 4000)
  backend_H1 <- SBC_backend_rstan_sample(m_H1, init = 0, control = list(adapt_delta = 0.9))
  res_test1 <- compute_SBC(ds_test_1, backend_H1, 
                           keep_fits = FALSE,
                           cache_mode = "results",
                           cache_location = file.path(cache_dir, paste0("SBC_turtles_H1_N", N, "_C",C,"_", length(ds_test_1), ".rds")))
  
  plot_ecdf_diff(res_test1, combine_variables = combine_array_elements)
}
```


```{r test0}
if(do_tests) {
set.seed(5685432)
  N <- NULL
  C <- NULL
  ds_test_0 <- generate_datasets(SBC_generator_function(sim_turtles, N = N, C = C, model = 0, future.globals = gen_globals), n_sims = 4000)
  backend_H0 <- SBC_backend_rstan_sample(m_H0, init = 0, control = list(adapt_delta = 0.9))
  res_test0 <- compute_SBC(ds_test_0, backend_H0, 
                           keep_fits = FALSE,
                           cache_mode = "results",
                           cache_location = file.path(cache_dir, paste0("SBC_turtles_H0_N", N, "_C",C,"_", length(ds_test_0), ".rds")))
  
  plot_ecdf_diff(res_test0, combine_variables = combine_array_elements)
}
```


```{r shared-config}
N <- 60
C <- 10
N_sims <- 2000
iter <- 15500
warmup <- 500
init <- 0

inflation_factor <- 3 # How many more dataset need to be simulated to have enough non-extreme ones
y_bound <- 0.1 #Minimum proportion of 0s and 1s to consider the dataset usable
```


## Full original prior

```{r simulateds}

set.seed(3245822)
ds_turtles_m0 <- generate_datasets(SBC_generator_function(sim_turtles, model = 0, N = N, C = C, future.globals = gen_globals), n_sims = N_sims * inflation_factor)
ds_turtles_m1 <- generate_datasets(SBC_generator_function(sim_turtles, model = 1, N = N, C = C, future.globals = gen_globals), n_sims = N_sims * inflation_factor)

set.seed(68234245)
ds_turtles_raw <- SBC_datasets_for_bf(ds_turtles_m0, ds_turtles_m1)
```

Subset the simulated dataset to gain `N_sims` usable datasets

```{r}
y_means <- purrr::map_dbl(ds_turtles_raw$generated, \(x) { mean(x$y)})
useful_ds <- y_means > y_bound & y_means < (1 - y_bound)
stopifnot(sum(useful_ds) >= N_sims)
ds_turtles <- (ds_turtles_raw[which(useful_ds)])[1:N_sims]
```


```{r turtles1}
backend_turtles <- SBC_backend_bridgesampling(
  SBC_backend_rstan_sample(m_H0, iter = iter, warmup = warmup, init = init),
  SBC_backend_rstan_sample(m_H1, iter = iter, warmup = warmup, init = init)
)
res_turtles <- compute_SBC(ds_turtles, backend_turtles, 
                           keep_fits = FALSE,
                           cache_mode = "results",
                           cache_location = file.path(cache_dir, "turtles.rds"))
```


```{r}
plot_ecdf_diff(res_turtles, combine_variables = combine_array_elements)
```

```{r}
bp_turtles <- binary_probabilities_from_stats(res_turtles$stats)

t_res_orig <- t.test(bp_turtles$prob, as.numeric(ds_turtles$variables[,"model"]))
t_res_orig
miscalibration_p_orig <- miscalibration_resampling_p(bp_turtles$prob, bp_turtles$simulated_value)
miscalibration_p_orig
my_reliability_diag(bp_turtles)
```


```{r save-stats}
saveRDS(list(t  = t_res_orig,
       miscalibration_p = miscalibration_p_orig),
  file.path(cache_dir, paste0("turtles_stats.rds")))

```

## Normal prior on sigma

```{r simulateds-norm}

set.seed(14565231)
ds_turtles_m1_norm <- generate_datasets(SBC_generator_function(sim_turtles, model = 1, N = N, C = C, sigma2_prior = "sqrt_norm", future.globals = gen_globals), n_sims = N_sims * inflation_factor)

set.seed(8451234)
ds_turtles_raw_norm <- SBC_datasets_for_bf(ds_turtles_m0, ds_turtles_m1_norm)
```

Subset the simulated dataset to gain `N_sims` usable datasets

```{r}
y_means <- purrr::map_dbl(ds_turtles_raw_norm$generated, \(x) { mean(x$y)})
useful_ds <- y_means > y_bound & y_means < (1 - y_bound)
stopifnot(sum(useful_ds) >= N_sims)
ds_turtles_norm <- (ds_turtles_raw_norm[which(useful_ds)])[1:N_sims]
```


```{r turtles-norm}
backend_turtles_norm <- SBC_backend_bridgesampling(
  SBC_backend_rstan_sample(m_H0, iter = iter, warmup = warmup, init = init),
  SBC_backend_rstan_sample(m_H1_norm, iter = iter, warmup = warmup, init = init)
)
res_turtles_norm <- compute_SBC(ds_turtles_norm, backend_turtles_norm, 
                           keep_fits = FALSE,
                           cache_mode = "results",
                           cache_location = file.path(cache_dir, "turtles_norm.rds"))
```


```{r}
plot_ecdf_diff(res_turtles_norm, combine_variables = combine_array_elements)
```

```{r}
bp_turtles_norm <- binary_probabilities_from_stats(res_turtles_norm$stats)

t.test(bp_turtles_norm$prob, as.numeric(ds_turtles_norm$variables[,"model"]))
miscalibration_resampling_p(bp_turtles_norm$prob, bp_turtles_norm$simulated_value)
my_reliability_diag(bp_turtles_norm)
```


## Normal prior, bad normalization

Using the same datasets as in the previous section, but the backend is bad.


```{r turtles-norm-bad}
backend_turtles_norm_bad <- SBC_backend_bridgesampling(
  SBC_backend_rstan_sample(m_H0, iter = iter, warmup = warmup, init = init),
  SBC_backend_rstan_sample(m_H1_norm_bad, iter = iter, warmup = warmup, init = init)
)
res_turtles_norm_bad <- compute_SBC_cache_blocks(ds_turtles_norm, backend_turtles_norm_bad, 
                           keep_fits = FALSE,
                           cache_prefix = file.path(cache_dir, "turtles_norm_bad_"),
                           block_size = 400)
```



```{r}
plot_ecdf_diff(res_turtles_norm_bad, combine_variables = combine_array_elements)
```

```{r}
bp_turtles_norm_bad <- binary_probabilities_from_stats(res_turtles_norm_bad$stats)

t.test(bp_turtles_norm_bad$prob, as.numeric(ds_turtles_norm$variables[,"model"]))
miscalibration_resampling_p(bp_turtles_norm_bad$prob, bp_turtles_norm_bad$simulated_value)
my_reliability_diag(bp_turtles_norm_bad)
```

```{r}
hist_length_turtles_norm_bad <- 400
invisible(get_precomputed_gamma_thresholds(unique(res_turtles_norm_bad$stats$max_rank) + 1,min_sims = 1, max_sims = max(1000,hist_length_turtles_norm_bad)))

hist_step_turtles_norm_bad <- 2
n_histories <- 100
hist_turtles_norm_bad <- compute_bootstrapped_histories(res_turtles_norm_bad$stats |> filter(variable %in% c("model", "sigma", "lp__")), history_length = hist_length_turtles_norm_bad, n_histories = n_histories, step = hist_step_turtles_norm_bad,
                                            compute_log_gamma_history)

bp_turtles_norm_bad <- binary_probabilities_from_stats(res_turtles_norm_bad$stats)
hist_turtles_norm_bad_ttest <- compute_bootstrapped_histories(bp_turtles_norm_bad, history_length = hist_length_turtles_norm_bad, n_histories = n_histories, step = hist_step_turtles_norm_bad,
                                            compute_ttest_history, expected = "avg_true")



hist_turtles_norm_bad_brier <- compute_bootstrapped_histories(bp_turtles_norm_bad, history_length = hist_length_turtles_norm_bad, n_histories = n_histories, step = hist_step_turtles_norm_bad,
                                            compute_brier_history, min_sim_id = 10)


hist_turtles_norm_bad_miscalibration <- compute_bootstrapped_histories(bp_turtles_norm_bad, history_length = hist_length_turtles_norm_bad, n_histories = n_histories, step = hist_step_turtles_norm_bad,
                                                           compute_miscalibration_history, min_sim_id = 10)




plot_log_gamma_histories(hist_turtles_norm_bad)
plot_log_p_histories(hist_turtles_norm_bad_brier, "Brier resampling")
plot_log_p_histories(hist_turtles_norm_bad_ttest, "DAP - t-test")
plot_log_p_histories(hist_turtles_norm_bad_miscalibration, "Miscalibration resampling")

save_histories("hist_turtles_norm_bad",
               log_gamma = hist_turtles_norm_bad,
               ttest = hist_turtles_norm_bad_ttest,
               miscalibration = hist_turtles_norm_bad_miscalibration)
```


## Posterior SBC - half dataset

Fit the first half of the dataset and compute BF.

```{r}
set.seed(6846523)
clutches_to_keep <- sample(unique(turtles$clutch), size = floor(length(unique(turtles$clutch)) / 2))
clutch_dict <- 1:length(clutches_to_keep)
names(clutch_dict) <- clutches_to_keep
turtles_half <- turtles %>% filter(clutch %in% clutches_to_keep) %>% mutate(clutch = clutch_dict[as.character(clutch)])

m0_cache_file <- file.path(cache_dir, paste0("turtles_H0_half_fit_", rlang::hash(m_H0@model_code),"_",rlang::hash(turtles_half), ".rds"))
m1_cache_file <- file.path(cache_dir, paste0("turtles_H1_half_fit_", rlang::hash(m_H1@model_code),"_",rlang::hash(turtles_half), ".rds"))

stanfit_to_prior_draws <- function(fit) {
  fit |> 
    posterior::as_draws() |> 
    posterior::thin_draws(thin = 10) |> 
    posterior::merge_chains() |> 
    posterior::as_draws_rvars()
}


# Directly copying the settings from the `turtles` page in the manual
if(!file.exists(m0_cache_file)) {
  stanfit_H0_half <- sampling(m_H0,
                     data = list(y = turtles_half$y, x = turtles_half$x, N = nrow(turtles_half)),
                     iter = 15500, warmup = 500, chains = 10, cores = 10, refresh = 4000, seed = 456622342)
  
  draws_prior_H0_half <- stanfit_to_prior_draws(stanfit_H0_half)
  set.seed(321987524)
  bs_prior_H0_half <- bridgesampling::bridge_sampler(stanfit_H0_half)
  saveRDS(list(draws = draws_prior_H0_half, bs = bs_prior_H0_half), file = m0_cache_file)
} else {
  H0_half_cache <- readRDS(m0_cache_file)
  draws_prior_H0_half <- H0_half_cache$draws
  bs_prior_H0_half <- H0_half_cache$bs
}

if(!file.exists(m1_cache_file)) {
  stanfit_H1_half <- sampling(m_H1,
                   data = list(y = turtles_half$y, x = turtles_half$x, N = nrow(turtles_half),
                               C = max(turtles_half$clutch), clutch = turtles_half$clutch),
                   iter = 15500, warmup = 500, chains = 10, cores = 10, refresh = 4000, seed = 846522143)

  draws_prior_H1_half <- stanfit_to_prior_draws(stanfit_H1_half)
  set.seed(3452365)
  bs_prior_H1_half <- bridgesampling::bridge_sampler(stanfit_H1_half)
  saveRDS(list(draws = draws_prior_H1_half, bs = bs_prior_H1_half), file = m1_cache_file)
} else {
  H1_half_cache <- readRDS(m1_cache_file)
  draws_prior_H1_half <- H1_half_cache$draws
  bs_prior_H1_half <- H1_half_cache$bs
  
}
bf_prior_bs_half <- bridgesampling::bayes_factor(bs_prior_H1_half, bs_prior_H0_half)
#prob1_uniform_prior_half <- exp(bf_prior_bs_half$bf) / (1 + exp(bf_prior_bs_half$bf))
bf_prior_bs_half$bf / (1 + bf_prior_bs_half$bf)

# Tweak the prior assumed wihtout any data to have Pr(M1 | turtles) = target = 0.5
# I want: target = pi_marg(y | M1) * prob1_tweaked / (pi_marg(y | M1) * prob1_tweaked + pi_marg(y | M0) * (1 - prob1_tweaked))
prob1_target_half <- 0.5
marg_m0_half <- exp(bs_prior_H0_half$logml)
marg_m1_half <- exp(bs_prior_H1_half$logml)
prob1_tweaked_prior_half <- (marg_m0_half * prob1_target_half) / (marg_m1_half + marg_m0_half * prob1_target_half - marg_m1_half * prob1_target_half)

```


```{r simulateds-half}
N_per_old_clutch <- 0
C_new <- length(unique(turtles$clutch)) - length(clutches_to_keep)
N_per_new_clutch <- floor((nrow(turtles) - nrow(turtles_half)) / C_new)

set.seed(6846523)
ds_turtles_m0_half <- generate_datasets(
  SBC_generator_function(
    sim_turtles_post_sbc,
    data_prior = turtles_half,
    draws_prior_H0 = draws_prior_H0_half,
    draws_prior_H1 = draws_prior_H1_half,
    model = 0,
    N_per_old_clutch = N_per_old_clutch,
    N_per_new_clutch = N_per_new_clutch,
    C_new = C_new,
    future.globals = gen_globals
  ),
  n_sims = N_sims
)
ds_turtles_m1_half <- generate_datasets(
  SBC_generator_function(
    sim_turtles_post_sbc,
    data_prior = turtles_half,
    draws_prior_H0 = draws_prior_H0_half,
    draws_prior_H1 = draws_prior_H1_half,
    model = 1,
    N_per_old_clutch = N_per_old_clutch,
    N_per_new_clutch = N_per_new_clutch,
    C_new = C_new,
    future.globals = gen_globals
  ),
  n_sims = N_sims
)

set.seed(985243245)
ds_turtles_half <- SBC_datasets_for_bf(ds_turtles_m0_half, ds_turtles_m1_half, prob_H1 = prob1_target)
```

```{r turtles-post-half}
backend_turtles_half <- SBC_backend_bridgesampling(
  SBC_backend_rstan_sample(m_H0, iter = iter, warmup = warmup, init = init),
  SBC_backend_rstan_sample(m_H1, iter = iter, warmup = warmup, init = init),
  prior_prob1 = prob1_tweaked_prior_half
)
res_turtles_post_half <- compute_SBC_cache_blocks(ds_turtles_half, backend_turtles_half, 
                           keep_fits = FALSE,
                           cache_prefix = file.path(cache_dir, "turtles_post_half_"),
                           block_size = 500)
```


```{r}
plot_ecdf_diff(res_turtles_post_half, combine_variables = combine_array_elements)
# plot_ecdf_diff(res_turtles_post$stats |> mutate(variable = "all", sim_id = 1:n()))
# plot_rank_hist(res_turtles_post$stats |> mutate(variable = "all", sim_id = 1:n()), bins = 20)

```

```{r}
bp_turtles_post_half <- binary_probabilities_from_stats(res_turtles_post_half$stats)
t_res <- t.test(bp_turtles_post_half$prob, mu = prob1_target_half)
t_res
miscalibration_p <- miscalibration_resampling_p(bp_turtles_post_half$prob, bp_turtles_post_half$simulated_value)
miscalibration_p
my_reliability_diag(bp_turtles_post_half)
```


```{r save-stats-post-half}
saveRDS(list(t  = t_res,
       miscalibration_p = miscalibration_p,
       prob1_tweaked_prior = prob1_tweaked_prior_half),
  file.path(cache_dir, paste0("turtles_post_half_stats.rds")))

```


## Posterior SBC - full dataset

```{r}
data("turtles", package = "bridgesampling")

m0_cache_file <- file.path(cache_dir, paste0("turtles_H0_fit_", rlang::hash(m_H0@model_code), ".rds"))
m1_cache_file <- file.path(cache_dir, paste0("turtles_H1_fit_", rlang::hash(m_H1@model_code), ".rds"))

# Directly copying the settings from the `turtles` page in the manual
if(!file.exists(m0_cache_file)) {
  stanfit_H0 <- sampling(m_H0,
                     data = list(y = turtles$y, x = turtles$x, N = nrow(turtles)),
                     iter = 15500, warmup = 500, chains = 10, cores = 10, refresh = 4000, seed = 456622342)
  
  draws_prior_H0 <- stanfit_to_prior_draws(stanfit_H0)
  set.seed(321987524)
  bs_prior_H0 <- bridgesampling::bridge_sampler(stanfit_H0)
  saveRDS(list(draws = draws_prior_H0, bs = bs_prior_H0), file = m0_cache_file)
} else {
  h0_cache <- readRDS(m0_cache_file)
  draws_prior_H0 <- h0_cache$draws
  bs_prior_H0 <- h0_cache$bs
}

if(!file.exists(m1_cache_file)) {
  stanfit_H1 <- sampling(m_H1,
                   data = list(y = turtles$y, x = turtles$x, N = nrow(turtles),
                               C = max(turtles$clutch), clutch = turtles$clutch),
                   iter = 15500, warmup = 500, chains = 10, cores = 10, refresh = 4000, seed = 846522143)

  draws_prior_H1 <- stanfit_to_prior_draws(stanfit_H1)
  set.seed(3452365)
  bs_prior_H1 <- bridgesampling::bridge_sampler(stanfit_H1)
  saveRDS(list(draws = draws_prior_H1, bs = bs_prior_H1), file = m1_cache_file)
} else {
  h1_cache <- readRDS(m1_cache_file)
  draws_prior_H1 <- h1_cache$draws
  bs_prior_H1 <- h1_cache$bs
  
}
bf_prior_bs <- bridgesampling::bayes_factor(bs_prior_H1, bs_prior_H0)
prob1_uniform_prior <- bf_prior_bs$bf / (1 + bf_prior_bs$bf)

# Tweak the prior assumed wihtout any data to have Pr(M1 | turtles) = target = 0.5
# I want: target = pi_marg(y | M1) * prob1_tweaked / (pi_marg(y | M1) * prob1_tweaked + pi_marg(y | M0) * (1 - prob1_tweaked))
prob1_target <- 0.5
marg_m0 <- exp(bs_prior_H0$logml)
marg_m1 <- exp(bs_prior_H1$logml)
prob1_tweaked_prior <- (marg_m0 * prob1_target) / (marg_m1 + marg_m0 * prob1_target - marg_m1 * prob1_target)

```



## Simulator

```{r}
invisible(force(turtles))

gen_globals <- c("r_inv_one_plus_sq")

sim_turtles_post_sbc <- function(model, data_prior, draws_prior_H0, draws_prior_H1, N_per_old_clutch, N_per_new_clutch = 5, C_new = 0, sigma2_prior = "default") {
  if(model == 0) {
    prior_draw <- posterior::subset_draws(draws_prior_H0, draw = sample.int(posterior::ndraws(draws_prior_H0), size = 1))
  } else {
    prior_draw <- posterior::subset_draws(draws_prior_H1, draw = sample.int(posterior::ndraws(draws_prior_H1), size = 1))
  }
  
    alpha0_raw <- posterior::draws_of(prior_draw$alpha0_raw)[1]
    alpha1_raw <- posterior::draws_of(prior_draw$alpha1_raw)[1]
    alpha0 <- sqrt(10) * alpha0_raw
    alpha1 <- sqrt(10) * alpha1_raw

    old_clutch_ids <- unique(data_prior$clutch)
    new_clutch_ids <- seq(from = max(old_clutch_ids) + 1, length.out = C_new)
    clutch_new <- c(rep(old_clutch_ids, each = N_per_old_clutch),
                    rep(new_clutch_ids, each = N_per_new_clutch))     

    x_new <- sample(data_prior$x, size = length(clutch_new), replace = TRUE)

    
    log_lik_shared <- dnorm(alpha0_raw, log = TRUE) +
      dnorm(alpha1_raw, log = TRUE)
    
    if(model == 0) {
      predictor <- alpha0 + alpha1 * data_prior$x
      predictor_new <- alpha0 + alpha1 * x_new
      log_lik_spec <- 0
    } else {
      if(sigma2_prior == "default") {
        sigma2_clutch <- posterior::draws_of(prior_draw$sigma2)[1]
        sigma_clutch <- sqrt(sigma2_clutch)      
        
        sigma2_log_lik <- log(sigma2_clutch)  +# Jacobian
          (- 2 * log1p(sigma2_clutch))
      } else if(sigma2_prior == "sqrt_norm") {
        sigma_clutch <- posterior::draws_of(prior_draw$sigma)[1]

        sigma2_log_lik <- log(sigma_clutch)  +# Jacobian
          log(2) + dnorm(sigma_clutch, sd = 1, log = TRUE)
      } else {
        stop("Invalid sigma2_prior")
      }

      b_clutch_raw <- c(
        posterior::draws_of(prior_draw$b_raw)[1,], 
        rnorm(C_new))
      b_clutch <- b_clutch_raw * sigma_clutch
      
      predictor <- alpha0 + alpha1 * data_prior$x + b_clutch[data_prior$clutch]
      predictor_new <- alpha0 + alpha1 * x_new + b_clutch[clutch_new]
      
      log_lik_spec <- 
        sigma2_log_lik +
        sum(dnorm(b_clutch_raw, log = TRUE))
    }
    
    prob <- pnorm(predictor)
    prob_new <- pnorm(predictor_new)
    y_new <- rbinom(length(clutch_new), p = prob_new, size = 1)

  log_lik_predictor <- sum(dbinom(data_prior$y, size = 1, p = prob, log = TRUE)) +
    sum(dbinom(y_new, size = 1, p = prob_new, log = TRUE))
  
  variables <- list(
      alpha0 = alpha0,
      alpha1 = alpha1,
      lp__ = log_lik_shared + log_lik_spec + log_lik_predictor
    )
  
  if(model == 1) {
    variables$sigma <- sigma_clutch
    variables$b <- b_clutch
  } 

  list(
    generated = list(
      N = nrow(data_prior) + length(clutch_new),
      y = c(data_prior$y, y_new),
      x = c(data_prior$x, x_new),
      C = max(c(data_prior$clutch, clutch_new)),
      clutch = c(data_prior$clutch, clutch_new)
    ),
    variables = variables
  )
}
```



## Original prior

```{r shared-config}
N <- NULL
C <- NULL
N_sims <- 2000
iter <- 15500
warmup <- 500
init <- 0
```


```{r simulateds}
N_per_old_clutch <- 0
N_per_new_clutch <- 4
C_new <- 25

set.seed(345852)
ds_turtles_m0 <- generate_datasets(
  SBC_generator_function(
    sim_turtles_post_sbc,
    data_prior = turtles,
    draws_prior_H0 = draws_prior_H0,
    draws_prior_H1 = draws_prior_H1,
    model = 0,
    N_per_old_clutch = N_per_old_clutch,
    N_per_new_clutch = N_per_new_clutch,
    C_new = C_new,
    future.globals = gen_globals
  ),
  n_sims = N_sims
)
ds_turtles_m1 <- generate_datasets(
  SBC_generator_function(
    sim_turtles_post_sbc,
    data_prior = turtles,
    draws_prior_H0 = draws_prior_H0,
    draws_prior_H1 = draws_prior_H1,
    model = 1,
    N_per_old_clutch = N_per_old_clutch,
    N_per_new_clutch = N_per_new_clutch,
    C_new = C_new,
    future.globals = gen_globals
  ),
  n_sims = N_sims
)

set.seed(68234245)
ds_turtles <- SBC_datasets_for_bf(ds_turtles_m0, ds_turtles_m1, prob_H1 = prob1_target)
```

```{r turtles1}
backend_turtles <- SBC_backend_bridgesampling(
  SBC_backend_rstan_sample(m_H0, iter = iter, warmup = warmup, init = init),
  SBC_backend_rstan_sample(m_H1, iter = iter, warmup = warmup, init = init),
  prior_prob1 = prob1_tweaked_prior
)
res_turtles_post <- compute_SBC_cache_blocks(ds_turtles, backend_turtles, 
                           keep_fits = FALSE,
                           cache_prefix = file.path(cache_dir, "turtles_post_"),
                           block_size = 200)
```


```{r}
plot_ecdf_diff(res_turtles_post, combine_variables = combine_array_elements)
# plot_ecdf_diff(res_turtles_post$stats |> mutate(variable = "all", sim_id = 1:n()))
# plot_rank_hist(res_turtles_post$stats |> mutate(variable = "all", sim_id = 1:n()), bins = 20)

```

```{r}
bp_turtles_post <- binary_probabilities_from_stats(res_turtles_post$stats)
t.test(bp_turtles_post$prob, mu = 0.5)
miscalibration_resampling_p(bp_turtles_post$prob, bp_turtles_post$simulated_value)
my_reliability_diag(bp_turtles_post)
```



